{
  "title": "Supabase Per-User Custom Cards Implementation Plan",
  "version": "2.0.0",
  "status": "pending",
  "architecture_decision": {
    "auth_required": true,
    "guest_mode": false,
    "rationale": "Dashboard is auth-protected route. No localStorage, no migration, simpler implementation.",
    "see": "docs/ARCHITECTURE-DECISION.md"
  },
  "tasks": [
    {
      "id": 1,
      "name": "Create Supabase Database Schema",
      "description": "Create custom_cards table with user_id foreign key",
      "files": ["supabase/migrations/create_custom_cards_table.sql"],
      "implementation": {
        "sql": "create table if not exists public.custom_cards (\n  id uuid primary key default gen_random_uuid(),\n  user_id uuid references auth.users(id) on delete cascade not null,\n  title text not null check (char_length(title) <= 50),\n  icon_name text not null,\n  links jsonb not null,\n  created_at timestamp with time zone default now() not null,\n  updated_at timestamp with time zone default now() not null\n);\n\n-- Create index for faster user queries\ncreate index custom_cards_user_id_idx on public.custom_cards(user_id);\n\n-- Create index for ordering by created_at\ncreate index custom_cards_created_at_idx on public.custom_cards(created_at);"
      },
      "notes": [
        "Use gen_random_uuid() instead of uuid_generate_v4() (Postgres 13+)",
        "Add check constraint for title length",
        "links stored as JSONB for query flexibility",
        "Indexes for performance on user_id and created_at"
      ]
    },
    {
      "id": 2,
      "name": "Add Row Level Security Policies",
      "description": "Enable RLS so users can only access their own cards",
      "files": ["supabase/migrations/create_custom_cards_table.sql"],
      "implementation": {
        "sql": "-- Enable RLS\nalter table public.custom_cards enable row level security;\n\n-- Policy: Users can view their own cards\ncreate policy \"Users can view own custom cards\"\n  on public.custom_cards\n  for select\n  using (auth.uid() = user_id);\n\n-- Policy: Users can insert their own cards\ncreate policy \"Users can insert own custom cards\"\n  on public.custom_cards\n  for insert\n  with check (auth.uid() = user_id);\n\n-- Policy: Users can update their own cards\ncreate policy \"Users can update own custom cards\"\n  on public.custom_cards\n  for update\n  using (auth.uid() = user_id)\n  with check (auth.uid() = user_id);\n\n-- Policy: Users can delete their own cards\ncreate policy \"Users can delete own custom cards\"\n  on public.custom_cards\n  for delete\n  using (auth.uid() = user_id);"
      },
      "notes": [
        "RLS ensures data isolation per user",
        "auth.uid() returns current authenticated user's ID",
        "All CRUD operations protected by RLS"
      ]
    },
    {
      "id": 3,
      "name": "Add Updated Timestamp Trigger",
      "description": "Auto-update updated_at timestamp on row changes",
      "files": ["supabase/migrations/create_custom_cards_table.sql"],
      "implementation": {
        "sql": "-- Function to update updated_at timestamp\ncreate or replace function public.update_updated_at_column()\nreturns trigger as $$\nbegin\n  new.updated_at = now();\n  return new;\nend;\n$$ language plpgsql;\n\n-- Trigger to auto-update updated_at\ncreate trigger update_custom_cards_updated_at\n  before update on public.custom_cards\n  for each row\n  execute function public.update_updated_at_column();"
      },
      "notes": [
        "Automatically tracks when cards are modified",
        "Useful for sync and conflict resolution"
      ]
    },
    {
      "id": 4,
      "name": "Create Field Mapping Layer (snake_case ↔ camelCase)",
      "description": "Conversion layer between Database (snake_case) and App (camelCase)",
      "files": ["src/lib/api/field-mapping.ts"],
      "field_mappings": {
        "database_to_app": {
          "id": "id (no change)",
          "user_id": "NOT in CustomCard (DB only)",
          "title": "title (no change)",
          "icon_name": "iconName",
          "links": "links (no change)",
          "created_at": "createdAt",
          "updated_at": "NOT in CustomCard (DB only)"
        },
        "app_to_database": {
          "title": "title (no change)",
          "iconName": "icon_name",
          "links": "links (no change)"
        }
      },
      "implementation": {
        "types": {
          "CustomCardRow": "Database row (snake_case) - id, user_id, title, icon_name, links, created_at, updated_at",
          "CustomCardInsert": "Insert payload (snake_case) - user_id, title, icon_name, links",
          "CustomCardUpdate": "Update payload (snake_case) - title?, icon_name?, links?"
        },
        "functions": {
          "dbToApp": "function dbToApp(row: CustomCardRow): CustomCard - Converts DB row to app model",
          "appToInsert": "function appToInsert(card, userId): CustomCardInsert - Converts app model to insert payload",
          "appToUpdate": "function appToUpdate(updates): CustomCardUpdate - Converts app updates to DB payload",
          "isCustomCardRow": "function isCustomCardRow(obj): boolean - Type guard for runtime validation"
        }
      },
      "usage_in_api": {
        "fetch": "const rows = await supabase.from('custom_cards').select('*');\nreturn rows.map(dbToApp);",
        "create": "const payload = appToInsert(card, user.id);\nconst row = await supabase.from('custom_cards').insert(payload).single();\nreturn dbToApp(row);",
        "update": "const payload = appToUpdate(updates);\nconst row = await supabase.from('custom_cards').update(payload).eq('id', id).single();\nreturn dbToApp(row);"
      },
      "benefits": [
        "Type safety: Compile-time checks for correct field names",
        "Single source of truth: Conversion logic centralized",
        "Testable: Pure functions easy to unit test",
        "Maintainable: Add new fields in one place",
        "Clear boundaries: DB layer vs App layer separation"
      ],
      "notes": [
        "Complete implementation in docs/field-name-mapping.md",
        "Database uses snake_case (PostgreSQL convention)",
        "App uses camelCase (TypeScript convention)",
        "Conversion happens at API boundary only",
        "user_id injected from auth.getUser(), not from app",
        "updated_at auto-updated by DB trigger, not exposed to app"
      ],
      "documentation": "docs/field-name-mapping.md"
    },
    {
      "id": 5,
      "name": "Create Custom Cards API Service",
      "description": "CRUD functions for custom cards in Supabase with field mapping",
      "files": ["src/lib/api/custom-cards.ts"],
      "dependencies": ["Task 4 - Field mapping layer required"],
      "implementation": {
        "functions": {
          "fetchCustomCardsFromSupabase": {
            "signature": "(): Promise<CustomCard[]>",
            "description": "Fetch all cards for authenticated user",
            "steps": [
              "1. Get user from supabase.auth.getUser()",
              "2. SELECT * FROM custom_cards WHERE user_id = user.id",
              "3. Map rows using dbToApp() from Task 4",
              "4. Return CustomCard[] (camelCase)"
            ]
          },
          "createCustomCardInSupabase": {
            "signature": "(card: Omit<CustomCard, 'id' | 'createdAt'>): Promise<CustomCard>",
            "description": "Create new card",
            "steps": [
              "1. Get user from supabase.auth.getUser()",
              "2. Convert using appToInsert(card, user.id) from Task 4",
              "3. INSERT into custom_cards",
              "4. Convert returned row using dbToApp()",
              "5. Return CustomCard (camelCase)"
            ]
          },
          "updateCustomCardInSupabase": {
            "signature": "(id: string, updates: Partial<Omit<CustomCard, 'id' | 'createdAt'>>): Promise<CustomCard>",
            "description": "Update existing card",
            "steps": [
              "1. Get user from supabase.auth.getUser()",
              "2. Convert using appToUpdate(updates) from Task 4",
              "3. UPDATE custom_cards WHERE id = id AND user_id = user.id",
              "4. Convert returned row using dbToApp()",
              "5. Return CustomCard (camelCase)"
            ]
          },
          "deleteCustomCardFromSupabase": {
            "signature": "(id: string): Promise<void>",
            "description": "Delete card",
            "steps": [
              "1. Get user from supabase.auth.getUser()",
              "2. DELETE FROM custom_cards WHERE id = id AND user_id = user.id",
              "3. Throw error if failed"
            ]
          }
        }
      },
      "error_handling": [
        "Throw 'Supabase not configured' if supabase is null",
        "Throw 'Not authenticated' if no user",
        "Throw Supabase error on query failure",
        "All errors propagate to caller (store) for handling"
      ],
      "security": [
        "user_id from auth.getUser(), never from caller",
        "RLS policies enforce user isolation",
        "UPDATE/DELETE include user_id check for safety"
      ],
      "notes": [
        "Uses field mapping from Task 4",
        "All functions async (return Promises)",
        "Error handling delegates to caller",
        "RLS automatically filters by user_id",
        "Complete implementation in docs/field-name-mapping.md"
      ]
    },
    {
      "id": 6,
      "name": "Update Zustand Store with Supabase Integration",
      "description": "Auth-only store with Supabase integration and optimistic updates",
      "files": ["src/stores/use-app-store.ts"],
      "implementation": {
        "interface": {
          "new_state": [
            "isLoadingCards: boolean - Loading state for async operations",
            "cardsError: string | null - Error message from failed operations"
          ],
          "actions": [
            "fetchCustomCards: () => Promise<void> - Fetch from Supabase",
            "addCustomCard: (card) => Promise<void> - Add with optimistic update",
            "updateCustomCard: (id, updates) => Promise<void> - Update with optimistic update",
            "deleteCustomCard: (id) => Promise<void> - Delete with optimistic update",
            "clearCardsError: () => void - Clear error state"
          ]
        },
        "optimistic_update_pattern": {
          "add": "1. Generate temp ID\n2. Add temp card to state\n3. Insert to Supabase\n4. On success: replace temp with server card\n5. On failure: remove temp card + set error",
          "update": "1. Store original card\n2. Apply update to state\n3. Update in Supabase\n4. On failure: rollback to original + set error",
          "delete": "1. Store original card\n2. Remove from state\n3. Delete from Supabase\n4. On failure: re-add original + set error"
        },
        "persistence_strategy": "partialize: (state) => ({\n  view: state.view,\n  sidebarOpen: state.sidebarOpen,\n  // Don't persist customCards (fetched from Supabase on auth)\n})"
      },
      "key_features": [
        "Supabase-only (no guest mode)",
        "Optimistic updates with automatic rollback on error",
        "Loading and error states for UI feedback",
        "Temp ID pattern (temp-${uuid}) for optimistic creates",
        "Original card backup for update/delete rollback",
        "Cards fetched from Supabase on sign-in, cleared on sign-out"
      ],
      "usage": "const { fetchCustomCards, addCustomCard, isLoadingCards, cardsError } = useAppStore();\nuseEffect(() => { if (user) fetchCustomCards(); }, [user?.id]);\nawait addCustomCard(data);",
      "error_handling": [
        "Network errors: Rollback optimistic update, set cardsError",
        "Validation errors: Thrown to caller for UI handling",
        "All errors re-thrown after rollback for toast notifications"
      ],
      "notes": [
        "ARCHITECTURE: Auth-only, no guest mode (see docs/ARCHITECTURE-DECISION.md)",
        "Complete implementation in docs/zustand-supabase-store-implementation.md",
        "Optimistic updates provide instant UI feedback",
        "Rollback mechanism ensures data consistency"
      ]
    },
    {
      "id": 7,
      "name": "Create useCustomCards Hook",
      "description": "React hook to manage custom cards with auth integration",
      "files": ["src/hooks/use-custom-cards.ts"],
      "implementation": {
        "hook": "export function useCustomCards() {\n  const { user } = useAuth();\n  const { customCards, fetchCustomCards, addCustomCard, updateCustomCard, deleteCustomCard, isLoading, error } = useAppStore();\n\n  // Fetch cards on mount if authenticated\n  useEffect(() => {\n    if (user) {\n      fetchCustomCards();\n    }\n  }, [user?.id]);\n\n  return {\n    cards: customCards,\n    isLoading,\n    error,\n    addCard: addCustomCard,\n    updateCard: updateCustomCard,\n    deleteCard: deleteCustomCard,\n  };\n}"
      },
      "notes": [
        "Abstracts store complexity",
        "Auto-fetches on auth state change",
        "Provides clean API for components"
      ]
    },
    {
      "id": 8,
      "name": "Update Dashboard to Use New Hook",
      "description": "Replace direct store usage with useCustomCards hook",
      "files": ["src/app/(app)/dashboard/page.tsx"],
      "changes": [
        "Replace useAppStore with useCustomCards",
        "Add loading spinner while fetching",
        "Add error toast on failures",
        "Handle auth vs non-auth states"
      ],
      "notes": [
        "Show skeleton loaders while isLoading",
        "Display error messages with retry button",
        "Graceful fallback for non-auth users"
      ]
    },
    {
      "id": 9,
      "name": "Update Auth Provider for Card Lifecycle",
      "description": "Clear cards on sign-out (auth-only, no migration needed)",
      "files": ["src/lib/auth-context.tsx"],
      "existing_implementation": {
        "status": "Already exists - needs minor enhancement",
        "current_features": [
          "AuthProvider component wraps app",
          "useAuth hook provides user, loading, signIn, signUp, signOut, resetPassword",
          "onAuthStateChange listener updates user state",
          "Session persistence via Supabase SDK",
          "Automatic token refresh"
        ],
        "user_object": {
          "id": "string - Supabase user UUID (use for DB queries)",
          "email": "string - User email",
          "full_name": "string | undefined - Display name from user_metadata",
          "avatar_url": "string | undefined - Avatar URL from user_metadata"
        }
      },
      "required_changes": [
        "Import useAppStore to clear cards on sign-out",
        "Add card clearing in onAuthStateChange SIGNED_OUT event"
      ],
      "implementation": {
        "code": "import { useAppStore } from '@/stores/use-app-store';\n\n// In onAuthStateChange listener:\nsupabase.auth.onAuthStateChange((event, session) => {\n  setUser(session?.user ?? null);\n  setLoading(false);\n\n  // Clear Supabase cards on sign-out\n  if (event === 'SIGNED_OUT') {\n    useAppStore.setState({ customCards: [] });\n  }\n});"
      },
      "auth_events": {
        "SIGNED_IN": "No action needed (fetchCustomCards called by useEffect in dashboard)",
        "SIGNED_OUT": "Clear customCards from Zustand state",
        "TOKEN_REFRESHED": "No action needed (automatic)",
        "USER_UPDATED": "No action needed (user state updates automatically)",
        "PASSWORD_RECOVERY": "No action needed for custom cards"
      },
      "notes": [
        "ARCHITECTURE: Auth-only, no migration needed (see docs/ARCHITECTURE-DECISION.md)",
        "useAuth hook already exists - see docs/auth-integration.md",
        "Cards cleared on sign-out to prevent stale data",
        "fetchCustomCards triggered by useCustomCards hook in dashboard"
      ],
      "documentation": "docs/auth-integration.md"
    },
    {
      "id": 10,
      "name": "Add Route Protection to Dashboard",
      "description": "Protect dashboard route - require authentication",
      "files": ["src/app/(app)/dashboard/page.tsx"],
      "implementation": {
        "code": "import { useAuth } from '@/lib/auth-context';\nimport { useRouter } from 'next/navigation';\nimport { useEffect } from 'react';\n\nexport default function Dashboard() {\n  const { user, loading } = useAuth();\n  const router = useRouter();\n\n  useEffect(() => {\n    if (!loading && !user) {\n      router.push('/login');\n    }\n  }, [user, loading, router]);\n\n  if (loading) return <Spinner />;\n  if (!user) return null; // Redirecting\n\n  return <DashboardContent />;\n}"
      },
      "required_changes": [
        "Import useAuth hook",
        "Import useRouter for navigation",
        "Add auth check in useEffect",
        "Show loading spinner during auth check",
        "Redirect to /login if not authenticated",
        "Render dashboard only when authenticated"
      ],
      "notes": [
        "ARCHITECTURE: Auth-only dashboard (see docs/ARCHITECTURE-DECISION.md)",
        "Default cards (Prompts, Git Commands, etc.) can be on different public route",
        "Custom cards only accessible when authenticated",
        "useCustomCards hook will auto-fetch on mount"
      ]
    },
    {
      "id": 11,
      "name": "Add Optimistic Updates",
      "description": "Update UI immediately, rollback on server error",
      "files": ["src/stores/use-app-store.ts"],
      "implementation": {
        "pattern": "1. Add card to state immediately\n2. Call Supabase API\n3. On success: update with server ID\n4. On failure: remove from state + show error"
      },
      "notes": [
        "Better UX with instant feedback",
        "Graceful error handling",
        "State consistency with server"
      ]
    },
    {
      "id": 12,
      "name": "Add Realtime Sync (Optional)",
      "description": "Sync cards across devices in realtime",
      "files": ["src/hooks/use-custom-cards.ts"],
      "implementation": {
        "code": "// Subscribe to changes\nconst subscription = supabase\n  .channel('custom_cards_changes')\n  .on('postgres_changes', {\n    event: '*',\n    schema: 'public',\n    table: 'custom_cards',\n    filter: `user_id=eq.${userId}`\n  }, (payload) => {\n    // Update local state\n  })\n  .subscribe();"
      },
      "notes": [
        "Optional enhancement",
        "Useful for multi-device users",
        "Requires Realtime enabled in Supabase"
      ]
    }
  ],
  "implementation_order": [
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12
  ],
  "removed_tasks": [
    {
      "original_id": 9,
      "name": "localStorage Migration",
      "reason": "Auth-only architecture - no guest mode, no migration needed"
    }
  ],
  "testing_checklist": [
    {
      "category": "Database",
      "tests": [
        "✓ Table created with correct schema",
        "✓ RLS policies prevent cross-user access",
        "✓ Indexes improve query performance",
        "✓ Triggers update timestamps correctly"
      ]
    },
    {
      "category": "API",
      "tests": [
        "✓ fetchCustomCards returns only user's cards",
        "✓ createCustomCard adds card to database",
        "✓ updateCustomCard modifies existing card",
        "✓ deleteCustomCard removes card",
        "✓ Error handling for network failures",
        "✓ RLS blocks unauthorized access attempts"
      ]
    },
    {
      "category": "Store",
      "tests": [
        "✓ fetchCustomCards loads from Supabase",
        "✓ Loading states update correctly",
        "✓ Error states clear on success",
        "✓ Optimistic updates rollback on error",
        "✓ Cards cleared on sign-out"
      ]
    },
    {
      "category": "Route Protection",
      "tests": [
        "✓ Dashboard redirects to /login when not authenticated",
        "✓ Dashboard shows loading spinner during auth check",
        "✓ Dashboard renders only when authenticated",
        "✓ Custom cards fetch on mount (authenticated users)"
      ]
    },
    {
      "category": "UI/UX",
      "tests": [
        "✓ Loading spinner shows while fetching",
        "✓ Error messages display with retry option",
        "✓ Cards update across devices (if realtime enabled)",
        "✓ Optimistic updates feel instant",
        "✓ Sign-out clears cards from state"
      ]
    }
  ],
  "rollback_plan": {
    "description": "Auth-only mode - no localStorage fallback",
    "approach": "Show error state with retry option",
    "steps": [
      "If fetchCustomCards fails: Display error message",
      "Provide 'Retry' button to re-fetch",
      "If auth fails: Redirect to /login",
      "No offline mode (auth required)"
    ]
  },
  "security_considerations": [
    "RLS policies enforce user data isolation",
    "JSONB validation prevents malicious data",
    "Rate limiting on Supabase prevents abuse",
    "Auth tokens stored securely via Supabase SDK"
  ],
  "performance_considerations": [
    "Index on user_id for fast queries",
    "JSONB for flexible link storage without joins",
    "Optimistic updates reduce perceived latency",
    "Realtime subscriptions use WebSockets (efficient)"
  ],
  "edge_cases": [
    {
      "case": "User signs out",
      "handling": "Clear Supabase cards from state, don't save to localStorage"
    },
    {
      "case": "User deletes account",
      "handling": "ON DELETE CASCADE removes all cards automatically"
    },
    {
      "case": "Network offline",
      "handling": "Show error, allow retry, or fall back to localStorage"
    },
    {
      "case": "Conflicting updates",
      "handling": "Last write wins (or implement CRDT for conflict-free sync)"
    }
  ],
  "next_steps_after_implementation": [
    "Add card sharing (share custom cards with other users)",
    "Add card templates (pre-built cards users can clone)",
    "Add card categories/tags for organization",
    "Add card search/filter functionality",
    "Add card export/import (JSON)",
    "Add card analytics (most used actions)"
  ]
}
