{
  "title": "Supabase Per-User Custom Cards Implementation Plan",
  "version": "1.0.0",
  "status": "pending",
  "tasks": [
    {
      "id": 1,
      "name": "Create Supabase Database Schema",
      "description": "Create custom_cards table with user_id foreign key",
      "files": ["supabase/migrations/create_custom_cards_table.sql"],
      "implementation": {
        "sql": "create table if not exists public.custom_cards (\n  id uuid primary key default gen_random_uuid(),\n  user_id uuid references auth.users(id) on delete cascade not null,\n  title text not null check (char_length(title) <= 50),\n  icon_name text not null,\n  links jsonb not null,\n  created_at timestamp with time zone default now() not null,\n  updated_at timestamp with time zone default now() not null\n);\n\n-- Create index for faster user queries\ncreate index custom_cards_user_id_idx on public.custom_cards(user_id);\n\n-- Create index for ordering by created_at\ncreate index custom_cards_created_at_idx on public.custom_cards(created_at);"
      },
      "notes": [
        "Use gen_random_uuid() instead of uuid_generate_v4() (Postgres 13+)",
        "Add check constraint for title length",
        "links stored as JSONB for query flexibility",
        "Indexes for performance on user_id and created_at"
      ]
    },
    {
      "id": 2,
      "name": "Add Row Level Security Policies",
      "description": "Enable RLS so users can only access their own cards",
      "files": ["supabase/migrations/create_custom_cards_table.sql"],
      "implementation": {
        "sql": "-- Enable RLS\nalter table public.custom_cards enable row level security;\n\n-- Policy: Users can view their own cards\ncreate policy \"Users can view own custom cards\"\n  on public.custom_cards\n  for select\n  using (auth.uid() = user_id);\n\n-- Policy: Users can insert their own cards\ncreate policy \"Users can insert own custom cards\"\n  on public.custom_cards\n  for insert\n  with check (auth.uid() = user_id);\n\n-- Policy: Users can update their own cards\ncreate policy \"Users can update own custom cards\"\n  on public.custom_cards\n  for update\n  using (auth.uid() = user_id)\n  with check (auth.uid() = user_id);\n\n-- Policy: Users can delete their own cards\ncreate policy \"Users can delete own custom cards\"\n  on public.custom_cards\n  for delete\n  using (auth.uid() = user_id);"
      },
      "notes": [
        "RLS ensures data isolation per user",
        "auth.uid() returns current authenticated user's ID",
        "All CRUD operations protected by RLS"
      ]
    },
    {
      "id": 3,
      "name": "Add Updated Timestamp Trigger",
      "description": "Auto-update updated_at timestamp on row changes",
      "files": ["supabase/migrations/create_custom_cards_table.sql"],
      "implementation": {
        "sql": "-- Function to update updated_at timestamp\ncreate or replace function public.update_updated_at_column()\nreturns trigger as $$\nbegin\n  new.updated_at = now();\n  return new;\nend;\n$$ language plpgsql;\n\n-- Trigger to auto-update updated_at\ncreate trigger update_custom_cards_updated_at\n  before update on public.custom_cards\n  for each row\n  execute function public.update_updated_at_column();"
      },
      "notes": [
        "Automatically tracks when cards are modified",
        "Useful for sync and conflict resolution"
      ]
    },
    {
      "id": 4,
      "name": "Create TypeScript Types for Database",
      "description": "Add Supabase database types",
      "files": ["src/types/database.ts"],
      "implementation": {
        "typescript": "export interface CustomCardRow {\n  id: string;\n  user_id: string;\n  title: string;\n  icon_name: string;\n  links: {\n    id: string;\n    label: string;\n    href: string;\n  }[];\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface CustomCardInsert {\n  user_id: string;\n  title: string;\n  icon_name: string;\n  links: {\n    id: string;\n    label: string;\n    href: string;\n  }[];\n}\n\nexport interface CustomCardUpdate {\n  title?: string;\n  icon_name?: string;\n  links?: {\n    id: string;\n    label: string;\n    href: string;\n  }[];\n}"
      },
      "notes": [
        "Separate types for Row, Insert, Update operations",
        "links array type matches CustomLink from store"
      ]
    },
    {
      "id": 5,
      "name": "Create Custom Cards API Service",
      "description": "CRUD functions for custom cards in Supabase",
      "files": ["src/lib/api/custom-cards.ts"],
      "implementation": {
        "functions": [
          "fetchCustomCards(userId: string): Promise<CustomCardRow[]>",
          "createCustomCard(data: CustomCardInsert): Promise<CustomCardRow>",
          "updateCustomCard(id: string, data: CustomCardUpdate): Promise<CustomCardRow>",
          "deleteCustomCard(id: string): Promise<void>"
        ]
      },
      "notes": [
        "All functions use Supabase client",
        "Error handling for network failures",
        "RLS automatically filters by user_id"
      ]
    },
    {
      "id": 6,
      "name": "Update Zustand Store with Supabase Integration",
      "description": "Hybrid store: Supabase for auth users, localStorage for guests, with optimistic updates",
      "files": ["src/stores/use-app-store.ts"],
      "implementation": {
        "interface": {
          "new_state": [
            "isLoadingCards: boolean - Loading state for async operations",
            "cardsError: string | null - Error message from failed operations"
          ],
          "async_actions": [
            "fetchCustomCards: () => Promise<void> - Fetch from Supabase",
            "addCustomCard: (card) => Promise<void> - Add with optimistic update",
            "updateCustomCard: (id, updates) => Promise<void> - Update with optimistic update",
            "deleteCustomCard: (id) => Promise<void> - Delete with optimistic update"
          ],
          "sync_actions": [
            "addCustomCardLocal: (card) => void - localStorage add for guests",
            "updateCustomCardLocal: (id, updates) => void - localStorage update for guests",
            "deleteCustomCardLocal: (id) => void - localStorage delete for guests"
          ],
          "utility": [
            "clearCardsError: () => void - Clear error state"
          ]
        },
        "optimistic_update_pattern": {
          "add": "1. Generate temp ID\n2. Add temp card to state\n3. Insert to Supabase\n4. On success: replace temp with server card\n5. On failure: remove temp card + set error",
          "update": "1. Store original card\n2. Apply update to state\n3. Update in Supabase\n4. On failure: rollback to original + set error",
          "delete": "1. Store original card\n2. Remove from state\n3. Delete from Supabase\n4. On failure: re-add original + set error"
        },
        "auth_detection": "async function isAuthenticated(): Promise<boolean> {\n  if (!supabase) return false;\n  const { data: { user } } = await supabase.auth.getUser();\n  return !!user;\n}",
        "persistence_strategy": "partialize: (state) => ({\n  view: state.view,\n  sidebarOpen: state.sidebarOpen,\n  customCards: state.customCards, // Always persist, auth users override on fetch\n})"
      },
      "key_features": [
        "Dual API: Async methods for auth, sync methods for guests",
        "Optimistic updates with automatic rollback on error",
        "Loading and error states for UI feedback",
        "Auth detection via supabase.auth.getUser()",
        "Temp ID pattern (temp-${uuid}) for optimistic creates",
        "Original card backup for update/delete rollback",
        "Conditional persistence (always save, fetch overrides for auth)"
      ],
      "usage_examples": {
        "auth_user": "const { fetchCustomCards, addCustomCard } = useAppStore();\nuseEffect(() => { if (user) fetchCustomCards(); }, [user?.id]);\nawait addCustomCard(data); // Optimistic",
        "guest_user": "const { addCustomCardLocal } = useAppStore();\naddCustomCardLocal(data); // Sync, auto-persisted",
        "unified_hook": "// Use useCustomCards() hook for automatic auth/guest detection"
      },
      "error_handling": [
        "Network errors: Rollback optimistic update, set cardsError",
        "Auth errors: Warn in console, don't execute async actions",
        "Validation errors: Thrown to caller for UI handling",
        "All errors re-thrown after rollback for toast notifications"
      ],
      "notes": [
        "Complete implementation in docs/zustand-supabase-store-implementation.md",
        "Hybrid approach: Supabase for auth users, localStorage for guests",
        "Optimistic updates provide instant UI feedback",
        "Rollback mechanism ensures data consistency",
        "Separate sync/async methods prevent auth confusion"
      ]
    },
    {
      "id": 7,
      "name": "Create useCustomCards Hook",
      "description": "React hook to manage custom cards with auth integration",
      "files": ["src/hooks/use-custom-cards.ts"],
      "implementation": {
        "hook": "export function useCustomCards() {\n  const { user } = useAuth();\n  const { customCards, fetchCustomCards, addCustomCard, updateCustomCard, deleteCustomCard, isLoading, error } = useAppStore();\n\n  // Fetch cards on mount if authenticated\n  useEffect(() => {\n    if (user) {\n      fetchCustomCards();\n    }\n  }, [user?.id]);\n\n  return {\n    cards: customCards,\n    isLoading,\n    error,\n    addCard: addCustomCard,\n    updateCard: updateCustomCard,\n    deleteCard: deleteCustomCard,\n  };\n}"
      },
      "notes": [
        "Abstracts store complexity",
        "Auto-fetches on auth state change",
        "Provides clean API for components"
      ]
    },
    {
      "id": 8,
      "name": "Update Dashboard to Use New Hook",
      "description": "Replace direct store usage with useCustomCards hook",
      "files": ["src/app/(app)/dashboard/page.tsx"],
      "changes": [
        "Replace useAppStore with useCustomCards",
        "Add loading spinner while fetching",
        "Add error toast on failures",
        "Handle auth vs non-auth states"
      ],
      "notes": [
        "Show skeleton loaders while isLoading",
        "Display error messages with retry button",
        "Graceful fallback for non-auth users"
      ]
    },
    {
      "id": 9,
      "name": "Add Data Migration Utility",
      "description": "Migrate existing localStorage cards to Supabase on first auth (Stage 2 migration: localStorage→Supabase)",
      "files": ["src/lib/migrate-cards-to-supabase.ts"],
      "implementation": {
        "function": "export async function migrateLocalStorageCardsToSupabase(userId: string) {\n  // 1. Read from Zustand store (already at v1 after Stage 1 migration)\n  const localCards = useAppStore.getState().customCards;\n\n  // 2. Check if migration already happened\n  const migrated = localStorage.getItem('supabase-migration-complete');\n  if (migrated === 'true' || localCards.length === 0) {\n    return;\n  }\n\n  try {\n    // 3. Batch insert to Supabase (cards already have links array from v0→v1 migration)\n    await Promise.all(\n      localCards.map(card => createCustomCard({\n        user_id: userId,\n        title: card.title,\n        icon_name: card.iconName,  // camelCase → snake_case\n        links: card.links,         // Already converted to array in Stage 1\n      }))\n    );\n\n    // 4. Verify count before clearing\n    const insertedCount = await supabase\n      .from('custom_cards')\n      .select('id', { count: 'exact', head: true })\n      .eq('user_id', userId);\n\n    if (insertedCount.count === localCards.length) {\n      // 5. Mark migration complete\n      localStorage.setItem('supabase-migration-complete', 'true');\n\n      // 6. Clear localStorage cards (keep other state)\n      useAppStore.setState({ customCards: [] });\n    } else {\n      throw new Error('Card count mismatch - migration incomplete');\n    }\n  } catch (error) {\n    console.error('Migration failed:', error);\n    throw error; // Don't mark as complete on failure\n  }\n}"
      },
      "notes": [
        "Stage 2 migration: localStorage (v1) → Supabase",
        "Assumes Stage 1 (v0→v1 href→links) already ran via Zustand persist",
        "One-time migration on first sign-in",
        "Migration flag prevents duplicate runs",
        "Verifies card count before clearing localStorage",
        "Rolls back on failure (allows retry next sign-in)",
        "See docs/custom-cards-migration-flow.md for complete flow"
      ],
      "migration_sequence": {
        "stage_1": "v0→v1 (href→links) - Zustand persist migration - Already implemented",
        "stage_2": "localStorage→Supabase - This task - To be implemented",
        "stage_3": "Supabase-only - Future state after migration completes"
      }
    },
    {
      "id": 10,
      "name": "Update Auth Provider to Trigger Migration",
      "description": "Enhance existing AuthProvider to trigger migration and clear cards on auth events",
      "files": ["src/lib/auth-context.tsx"],
      "existing_implementation": {
        "status": "Already exists - needs enhancement",
        "current_features": [
          "AuthProvider component wraps app",
          "useAuth hook provides user, loading, signIn, signUp, signOut, resetPassword",
          "onAuthStateChange listener updates user state",
          "Session persistence via Supabase SDK",
          "Automatic token refresh"
        ],
        "user_object": {
          "id": "string - Supabase user UUID (use for DB queries)",
          "email": "string - User email",
          "full_name": "string | undefined - Display name from user_metadata",
          "avatar_url": "string | undefined - Avatar URL from user_metadata"
        }
      },
      "required_changes": [
        "Import migrateLocalStorageCardsToSupabase from Task 9",
        "Import useAppStore to clear cards on sign-out",
        "Add migration trigger in onAuthStateChange SIGNED_IN event",
        "Add card clearing in onAuthStateChange SIGNED_OUT event",
        "Add error handling for migration failures (non-blocking)"
      ],
      "implementation": {
        "code": "supabase.auth.onAuthStateChange(async (event, session) => {\n  setUser(session?.user ?? null);\n  setLoading(false);\n\n  // Trigger migration on sign-in\n  if (event === 'SIGNED_IN' && session?.user) {\n    try {\n      await migrateLocalStorageCardsToSupabase(session.user.id);\n      // Migration will call fetchCustomCards internally\n    } catch (error) {\n      console.error('Card migration failed:', error);\n      toast.error('Failed to sync cards. Retrying on next sign-in.');\n    }\n  }\n\n  // Clear Supabase cards on sign-out\n  if (event === 'SIGNED_OUT') {\n    useAppStore.setState({ customCards: [] });\n  }\n});"
      },
      "auth_events": {
        "SIGNED_IN": "Trigger migration + fetch cards from Supabase",
        "SIGNED_OUT": "Clear customCards from Zustand state",
        "TOKEN_REFRESHED": "No action needed (automatic)",
        "USER_UPDATED": "No action needed (user state updates automatically)",
        "PASSWORD_RECOVERY": "No action needed for custom cards"
      },
      "notes": [
        "useAuth hook already exists - see docs/auth-integration.md",
        "Non-blocking migration (errors logged, user can continue)",
        "Error handling with toast notification",
        "Migration flag (in Task 9) prevents duplicate migrations",
        "Cards cleared on sign-out to prevent stale data"
      ],
      "documentation": "docs/auth-integration.md"
    },
    {
      "id": 11,
      "name": "Add Optimistic Updates",
      "description": "Update UI immediately, rollback on server error",
      "files": ["src/stores/use-app-store.ts"],
      "implementation": {
        "pattern": "1. Add card to state immediately\n2. Call Supabase API\n3. On success: update with server ID\n4. On failure: remove from state + show error"
      },
      "notes": [
        "Better UX with instant feedback",
        "Graceful error handling",
        "State consistency with server"
      ]
    },
    {
      "id": 12,
      "name": "Add Realtime Sync (Optional)",
      "description": "Sync cards across devices in realtime",
      "files": ["src/hooks/use-custom-cards.ts"],
      "implementation": {
        "code": "// Subscribe to changes\nconst subscription = supabase\n  .channel('custom_cards_changes')\n  .on('postgres_changes', {\n    event: '*',\n    schema: 'public',\n    table: 'custom_cards',\n    filter: `user_id=eq.${userId}`\n  }, (payload) => {\n    // Update local state\n  })\n  .subscribe();"
      },
      "notes": [
        "Optional enhancement",
        "Useful for multi-device users",
        "Requires Realtime enabled in Supabase"
      ]
    }
  ],
  "implementation_order": [
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12
  ],
  "testing_checklist": [
    {
      "category": "Database",
      "tests": [
        "✓ Table created with correct schema",
        "✓ RLS policies prevent cross-user access",
        "✓ Indexes improve query performance",
        "✓ Triggers update timestamps correctly"
      ]
    },
    {
      "category": "API",
      "tests": [
        "✓ fetchCustomCards returns only user's cards",
        "✓ createCustomCard adds card to database",
        "✓ updateCustomCard modifies existing card",
        "✓ deleteCustomCard removes card",
        "✓ Error handling for network failures",
        "✓ RLS blocks unauthorized access attempts"
      ]
    },
    {
      "category": "Store",
      "tests": [
        "✓ Auth users use Supabase",
        "✓ Non-auth users use localStorage",
        "✓ Loading states update correctly",
        "✓ Error states clear on success",
        "✓ Optimistic updates rollback on error"
      ]
    },
    {
      "category": "Migration",
      "tests": [
        "✓ localStorage cards migrate to Supabase on first sign-in",
        "✓ Migration doesn't run twice",
        "✓ localStorage cleared after successful migration",
        "✓ Migration errors handled gracefully"
      ]
    },
    {
      "category": "UI/UX",
      "tests": [
        "✓ Loading spinner shows while fetching",
        "✓ Error messages display with retry option",
        "✓ Cards update across devices (if realtime enabled)",
        "✓ Optimistic updates feel instant",
        "✓ Guest mode still works with localStorage"
      ]
    }
  ],
  "rollback_plan": {
    "description": "If Supabase integration fails, app should fall back to localStorage",
    "steps": [
      "Check if supabase.auth.getUser() succeeds",
      "On error, use localStorage mode",
      "Show toast: 'Offline mode - changes saved locally'",
      "Provide 'Retry Sync' button in settings"
    ]
  },
  "security_considerations": [
    "RLS policies enforce user data isolation",
    "JSONB validation prevents malicious data",
    "Rate limiting on Supabase prevents abuse",
    "Auth tokens stored securely via Supabase SDK"
  ],
  "performance_considerations": [
    "Index on user_id for fast queries",
    "JSONB for flexible link storage without joins",
    "Optimistic updates reduce perceived latency",
    "Realtime subscriptions use WebSockets (efficient)"
  ],
  "edge_cases": [
    {
      "case": "User signs out",
      "handling": "Clear Supabase cards from state, don't save to localStorage"
    },
    {
      "case": "User deletes account",
      "handling": "ON DELETE CASCADE removes all cards automatically"
    },
    {
      "case": "Network offline",
      "handling": "Show error, allow retry, or fall back to localStorage"
    },
    {
      "case": "Conflicting updates",
      "handling": "Last write wins (or implement CRDT for conflict-free sync)"
    }
  ],
  "next_steps_after_implementation": [
    "Add card sharing (share custom cards with other users)",
    "Add card templates (pre-built cards users can clone)",
    "Add card categories/tags for organization",
    "Add card search/filter functionality",
    "Add card export/import (JSON)",
    "Add card analytics (most used actions)"
  ]
}
