{
  "title": "Supabase Per-User Custom Cards Implementation Plan",
  "version": "2.0.0",
  "status": "pending",
  "architecture_decision": {
    "auth_required": true,
    "guest_mode": false,
    "rationale": "Dashboard is auth-protected route. No localStorage, no migration, simpler implementation.",
    "see": "docs/ARCHITECTURE-DECISION.md"
  },
  "tasks": [
    {
      "id": 1,
      "name": "Create Supabase Database Schema",
      "description": "Create custom_cards table with user_id foreign key",
      "files": ["supabase/migrations/create_custom_cards_table.sql"],
      "implementation": {
        "sql": "create table if not exists public.custom_cards (\n  id uuid primary key default gen_random_uuid(),\n  user_id uuid references auth.users(id) on delete cascade not null,\n  title text not null check (char_length(title) <= 50),\n  icon_name text not null,\n  links jsonb not null,\n  created_at timestamp with time zone default now() not null,\n  updated_at timestamp with time zone default now() not null\n);\n\n-- Create index for faster user queries\ncreate index custom_cards_user_id_idx on public.custom_cards(user_id);\n\n-- Create index for ordering by created_at\ncreate index custom_cards_created_at_idx on public.custom_cards(created_at);"
      },
      "notes": [
        "Use gen_random_uuid() instead of uuid_generate_v4() (Postgres 13+)",
        "Add check constraint for title length",
        "links stored as JSONB for query flexibility",
        "Indexes for performance on user_id and created_at"
      ]
    },
    {
      "id": 2,
      "name": "Add Row Level Security Policies",
      "description": "Enable RLS so users can only access their own cards",
      "files": ["supabase/migrations/create_custom_cards_table.sql"],
      "implementation": {
        "sql": "-- Enable RLS\nalter table public.custom_cards enable row level security;\n\n-- Policy: Users can view their own cards\ncreate policy \"Users can view own custom cards\"\n  on public.custom_cards\n  for select\n  using (auth.uid() = user_id);\n\n-- Policy: Users can insert their own cards\ncreate policy \"Users can insert own custom cards\"\n  on public.custom_cards\n  for insert\n  with check (auth.uid() = user_id);\n\n-- Policy: Users can update their own cards\ncreate policy \"Users can update own custom cards\"\n  on public.custom_cards\n  for update\n  using (auth.uid() = user_id)\n  with check (auth.uid() = user_id);\n\n-- Policy: Users can delete their own cards\ncreate policy \"Users can delete own custom cards\"\n  on public.custom_cards\n  for delete\n  using (auth.uid() = user_id);"
      },
      "notes": [
        "RLS ensures data isolation per user",
        "auth.uid() returns current authenticated user's ID",
        "All CRUD operations protected by RLS"
      ]
    },
    {
      "id": 3,
      "name": "Add Updated Timestamp Trigger",
      "description": "Auto-update updated_at timestamp on row changes",
      "files": ["supabase/migrations/create_custom_cards_table.sql"],
      "implementation": {
        "sql": "-- Function to update updated_at timestamp\ncreate or replace function public.update_updated_at_column()\nreturns trigger as $$\nbegin\n  new.updated_at = now();\n  return new;\nend;\n$$ language plpgsql;\n\n-- Trigger to auto-update updated_at\ncreate trigger update_custom_cards_updated_at\n  before update on public.custom_cards\n  for each row\n  execute function public.update_updated_at_column();"
      },
      "notes": [
        "Automatically tracks when cards are modified",
        "Useful for sync and conflict resolution"
      ]
    },
    {
      "id": 4,
      "name": "Create Field Mapping Layer (snake_case â†” camelCase)",
      "description": "Conversion layer between Database (snake_case) and App (camelCase)",
      "files": ["src/lib/api/field-mapping.ts"],
      "field_mappings": {
        "database_to_app": {
          "id": "id (no change)",
          "user_id": "NOT in CustomCard (DB only)",
          "title": "title (no change)",
          "icon_name": "iconName",
          "links": "links (no change)",
          "created_at": "createdAt",
          "updated_at": "NOT in CustomCard (DB only)"
        },
        "app_to_database": {
          "title": "title (no change)",
          "iconName": "icon_name",
          "links": "links (no change)"
        }
      },
      "implementation": {
        "types": {
          "CustomCardRow": "Database row (snake_case) - id, user_id, title, icon_name, links, created_at, updated_at",
          "CustomCardInsert": "Insert payload (snake_case) - user_id, title, icon_name, links",
          "CustomCardUpdate": "Update payload (snake_case) - title?, icon_name?, links?"
        },
        "functions": {
          "dbToApp": "function dbToApp(row: CustomCardRow): CustomCard - Converts DB row to app model",
          "appToInsert": "function appToInsert(card, userId): CustomCardInsert - Converts app model to insert payload",
          "appToUpdate": "function appToUpdate(updates): CustomCardUpdate - Converts app updates to DB payload",
          "isCustomCardRow": "function isCustomCardRow(obj): boolean - Type guard for runtime validation"
        }
      },
      "usage_in_api": {
        "fetch": "const rows = await supabase.from('custom_cards').select('*');\nreturn rows.map(dbToApp);",
        "create": "const payload = appToInsert(card, user.id);\nconst row = await supabase.from('custom_cards').insert(payload).single();\nreturn dbToApp(row);",
        "update": "const payload = appToUpdate(updates);\nconst row = await supabase.from('custom_cards').update(payload).eq('id', id).single();\nreturn dbToApp(row);"
      },
      "benefits": [
        "Type safety: Compile-time checks for correct field names",
        "Single source of truth: Conversion logic centralized",
        "Testable: Pure functions easy to unit test",
        "Maintainable: Add new fields in one place",
        "Clear boundaries: DB layer vs App layer separation"
      ],
      "notes": [
        "Complete implementation in docs/field-name-mapping.md",
        "Database uses snake_case (PostgreSQL convention)",
        "App uses camelCase (TypeScript convention)",
        "Conversion happens at API boundary only",
        "user_id injected from auth.getUser(), not from app",
        "updated_at auto-updated by DB trigger, not exposed to app"
      ],
      "documentation": "docs/field-name-mapping.md"
    },
    {
      "id": 5,
      "name": "Create Custom Cards API Service",
      "description": "CRUD functions for custom cards in Supabase with field mapping",
      "files": ["src/lib/api/custom-cards.ts"],
      "dependencies": ["Task 4 - Field mapping layer required"],
      "implementation": {
        "functions": {
          "fetchCustomCardsFromSupabase": {
            "signature": "(): Promise<CustomCard[]>",
            "description": "Fetch all cards for authenticated user",
            "steps": [
              "1. Get user from supabase.auth.getUser()",
              "2. SELECT * FROM custom_cards WHERE user_id = user.id",
              "3. Map rows using dbToApp() from Task 4",
              "4. Return CustomCard[] (camelCase)"
            ]
          },
          "createCustomCardInSupabase": {
            "signature": "(card: Omit<CustomCard, 'id' | 'createdAt'>): Promise<CustomCard>",
            "description": "Create new card",
            "steps": [
              "1. Get user from supabase.auth.getUser()",
              "2. Convert using appToInsert(card, user.id) from Task 4",
              "3. INSERT into custom_cards",
              "4. Convert returned row using dbToApp()",
              "5. Return CustomCard (camelCase)"
            ]
          },
          "updateCustomCardInSupabase": {
            "signature": "(id: string, updates: Partial<Omit<CustomCard, 'id' | 'createdAt'>>): Promise<CustomCard>",
            "description": "Update existing card",
            "steps": [
              "1. Get user from supabase.auth.getUser()",
              "2. Convert using appToUpdate(updates) from Task 4",
              "3. UPDATE custom_cards WHERE id = id AND user_id = user.id",
              "4. Convert returned row using dbToApp()",
              "5. Return CustomCard (camelCase)"
            ]
          },
          "deleteCustomCardFromSupabase": {
            "signature": "(id: string): Promise<void>",
            "description": "Delete card",
            "steps": [
              "1. Get user from supabase.auth.getUser()",
              "2. DELETE FROM custom_cards WHERE id = id AND user_id = user.id",
              "3. Throw error if failed"
            ]
          }
        }
      },
      "error_handling": [
        "Throw 'Supabase not configured' if supabase is null",
        "Throw 'Not authenticated' if no user",
        "Throw Supabase error on query failure",
        "All errors propagate to caller (store) for handling"
      ],
      "security": [
        "user_id from auth.getUser(), never from caller",
        "RLS policies enforce user isolation",
        "UPDATE/DELETE include user_id check for safety"
      ],
      "notes": [
        "Uses field mapping from Task 4",
        "All functions async (return Promises)",
        "Error handling delegates to caller",
        "RLS automatically filters by user_id",
        "Complete implementation in docs/field-name-mapping.md"
      ]
    },
    {
      "id": 6,
      "name": "Update Zustand Store with Supabase Integration",
      "description": "Auth-only store with Supabase integration and optimistic updates",
      "files": ["src/stores/use-app-store.ts"],
      "implementation": {
        "interface": {
          "new_state": [
            "isLoadingCards: boolean - Loading state for async operations",
            "cardsError: string | null - Error message from failed operations"
          ],
          "actions": [
            "fetchCustomCards: () => Promise<void> - Fetch from Supabase",
            "addCustomCard: (card) => Promise<void> - Add with optimistic update",
            "updateCustomCard: (id, updates) => Promise<void> - Update with optimistic update",
            "deleteCustomCard: (id) => Promise<void> - Delete with optimistic update",
            "clearCardsError: () => void - Clear error state"
          ]
        },
        "optimistic_update_pattern": {
          "add": "1. Generate temp ID\n2. Add temp card to state\n3. Insert to Supabase\n4. On success: replace temp with server card\n5. On failure: remove temp card + set error",
          "update": "1. Store original card\n2. Apply update to state\n3. Update in Supabase\n4. On failure: rollback to original + set error",
          "delete": "1. Store original card\n2. Remove from state\n3. Delete from Supabase\n4. On failure: re-add original + set error"
        },
        "persistence_strategy": "partialize: (state) => ({\n  view: state.view,\n  sidebarOpen: state.sidebarOpen,\n  // Don't persist customCards (fetched from Supabase on auth)\n})"
      },
      "key_features": [
        "Supabase-only (no guest mode)",
        "Optimistic updates with automatic rollback on error",
        "Loading and error states for UI feedback",
        "Temp ID pattern (temp-${uuid}) for optimistic creates",
        "Original card backup for update/delete rollback",
        "Cards fetched from Supabase on sign-in, cleared on sign-out"
      ],
      "usage": "const { fetchCustomCards, addCustomCard, isLoadingCards, cardsError } = useAppStore();\nuseEffect(() => { if (user) fetchCustomCards(); }, [user?.id]);\nawait addCustomCard(data);",
      "error_handling": [
        "Network errors: Rollback optimistic update, set cardsError",
        "Validation errors: Thrown to caller for UI handling",
        "All errors re-thrown after rollback for toast notifications"
      ],
      "notes": [
        "ARCHITECTURE: Auth-only, no guest mode (see docs/ARCHITECTURE-DECISION.md)",
        "Complete implementation in docs/zustand-supabase-store-implementation.md",
        "Optimistic updates provide instant UI feedback",
        "Rollback mechanism ensures data consistency"
      ]
    },
    {
      "id": 7,
      "name": "Create useCustomCards Hook",
      "description": "React hook to manage custom cards with auth integration",
      "files": ["src/hooks/use-custom-cards.ts"],
      "implementation": {
        "hook": "export function useCustomCards() {\n  const { user } = useAuth();\n  const { customCards, fetchCustomCards, addCustomCard, updateCustomCard, deleteCustomCard, isLoading, error } = useAppStore();\n\n  // Fetch cards on mount if authenticated\n  useEffect(() => {\n    if (user) {\n      fetchCustomCards();\n    }\n  }, [user?.id]);\n\n  return {\n    cards: customCards,\n    isLoading,\n    error,\n    addCard: addCustomCard,\n    updateCard: updateCustomCard,\n    deleteCard: deleteCustomCard,\n  };\n}"
      },
      "notes": [
        "Abstracts store complexity",
        "Auto-fetches on auth state change",
        "Provides clean API for components"
      ]
    },
    {
      "id": 8,
      "name": "Update Dashboard to Use New Hook",
      "description": "Replace direct store usage with useCustomCards hook",
      "files": ["src/app/(app)/dashboard/page.tsx"],
      "changes": [
        "Replace useAppStore with useCustomCards",
        "Add loading spinner while fetching",
        "Add error toast on failures",
        "Handle auth vs non-auth states"
      ],
      "notes": [
        "Show skeleton loaders while isLoading",
        "Display error messages with retry button",
        "Graceful fallback for non-auth users"
      ]
    },
    {
      "id": 9,
      "name": "Update Auth Provider for Card Lifecycle",
      "description": "Clear cards on sign-out (auth-only, no migration needed)",
      "files": ["src/lib/auth-context.tsx"],
      "existing_implementation": {
        "status": "Already exists - needs minor enhancement",
        "current_features": [
          "AuthProvider component wraps app",
          "useAuth hook provides user, loading, signIn, signUp, signOut, resetPassword",
          "onAuthStateChange listener updates user state",
          "Session persistence via Supabase SDK",
          "Automatic token refresh"
        ],
        "user_object": {
          "id": "string - Supabase user UUID (use for DB queries)",
          "email": "string - User email",
          "full_name": "string | undefined - Display name from user_metadata",
          "avatar_url": "string | undefined - Avatar URL from user_metadata"
        }
      },
      "required_changes": [
        "Import useAppStore to clear cards on sign-out",
        "Add card clearing in onAuthStateChange SIGNED_OUT event"
      ],
      "implementation": {
        "code": "import { useAppStore } from '@/stores/use-app-store';\n\n// In onAuthStateChange listener:\nsupabase.auth.onAuthStateChange((event, session) => {\n  setUser(session?.user ?? null);\n  setLoading(false);\n\n  // Clear Supabase cards on sign-out\n  if (event === 'SIGNED_OUT') {\n    useAppStore.setState({ customCards: [] });\n  }\n});"
      },
      "auth_events": {
        "SIGNED_IN": "No action needed (fetchCustomCards called by useEffect in dashboard)",
        "SIGNED_OUT": "Clear customCards from Zustand state",
        "TOKEN_REFRESHED": "No action needed (automatic)",
        "USER_UPDATED": "No action needed (user state updates automatically)",
        "PASSWORD_RECOVERY": "No action needed for custom cards"
      },
      "notes": [
        "ARCHITECTURE: Auth-only, no migration needed (see docs/ARCHITECTURE-DECISION.md)",
        "useAuth hook already exists - see docs/auth-integration.md",
        "Cards cleared on sign-out to prevent stale data",
        "fetchCustomCards triggered by useCustomCards hook in dashboard"
      ],
      "documentation": "docs/auth-integration.md"
    },
    {
      "id": 10,
      "name": "Add Route Protection to Dashboard",
      "description": "Protect dashboard route - require authentication",
      "files": ["src/app/(app)/dashboard/page.tsx"],
      "implementation": {
        "code": "import { useAuth } from '@/lib/auth-context';\nimport { useRouter } from 'next/navigation';\nimport { useEffect } from 'react';\n\nexport default function Dashboard() {\n  const { user, loading } = useAuth();\n  const router = useRouter();\n\n  useEffect(() => {\n    if (!loading && !user) {\n      router.push('/login');\n    }\n  }, [user, loading, router]);\n\n  if (loading) return <Spinner />;\n  if (!user) return null; // Redirecting\n\n  return <DashboardContent />;\n}"
      },
      "required_changes": [
        "Import useAuth hook",
        "Import useRouter for navigation",
        "Add auth check in useEffect",
        "Show loading spinner during auth check",
        "Redirect to /login if not authenticated",
        "Render dashboard only when authenticated"
      ],
      "notes": [
        "ARCHITECTURE: Auth-only dashboard (see docs/ARCHITECTURE-DECISION.md)",
        "Default cards (Prompts, Git Commands, etc.) can be on different public route",
        "Custom cards only accessible when authenticated",
        "useCustomCards hook will auto-fetch on mount"
      ]
    },
    {
      "id": 11,
      "name": "Add Optimistic Updates",
      "description": "Update UI immediately, rollback on server error",
      "files": ["src/stores/use-app-store.ts"],
      "implementation": {
        "pattern": "1. Add card to state immediately\n2. Call Supabase API\n3. On success: update with server ID\n4. On failure: remove from state + show error"
      },
      "notes": [
        "Better UX with instant feedback",
        "Graceful error handling",
        "State consistency with server"
      ]
    },
    {
      "id": 12,
      "name": "Add Realtime Sync (Optional)",
      "description": "Sync cards across devices in realtime",
      "files": ["src/hooks/use-custom-cards.ts"],
      "implementation": {
        "code": "// Subscribe to changes\nconst subscription = supabase\n  .channel('custom_cards_changes')\n  .on('postgres_changes', {\n    event: '*',\n    schema: 'public',\n    table: 'custom_cards',\n    filter: `user_id=eq.${userId}`\n  }, (payload) => {\n    // Update local state\n  })\n  .subscribe();"
      },
      "notes": [
        "Optional enhancement",
        "Useful for multi-device users",
        "Requires Realtime enabled in Supabase"
      ]
    }
  ],
  "implementation_order": [
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12
  ],
  "removed_tasks": [
    {
      "original_id": 9,
      "name": "localStorage Migration",
      "reason": "Auth-only architecture - no guest mode, no migration needed"
    }
  ],
  "testing_checklist": [
    {
      "category": "Database",
      "tests": [
        "âœ“ Table created with correct schema",
        "âœ“ RLS policies prevent cross-user access",
        "âœ“ Indexes improve query performance",
        "âœ“ Triggers update timestamps correctly"
      ]
    },
    {
      "category": "API",
      "tests": [
        "âœ“ fetchCustomCards returns only user's cards",
        "âœ“ createCustomCard adds card to database",
        "âœ“ updateCustomCard modifies existing card",
        "âœ“ deleteCustomCard removes card",
        "âœ“ Error handling for network failures",
        "âœ“ RLS blocks unauthorized access attempts"
      ]
    },
    {
      "category": "Store",
      "tests": [
        "âœ“ fetchCustomCards loads from Supabase",
        "âœ“ Loading states update correctly",
        "âœ“ Error states clear on success",
        "âœ“ Optimistic updates rollback on error",
        "âœ“ Cards cleared on sign-out"
      ]
    },
    {
      "category": "Route Protection",
      "tests": [
        "âœ“ Dashboard redirects to /login when not authenticated",
        "âœ“ Dashboard shows loading spinner during auth check",
        "âœ“ Dashboard renders only when authenticated",
        "âœ“ Custom cards fetch on mount (authenticated users)"
      ]
    },
    {
      "category": "UI/UX",
      "tests": [
        "âœ“ Loading spinner shows while fetching",
        "âœ“ Error messages display with retry option",
        "âœ“ Cards update across devices (if realtime enabled)",
        "âœ“ Optimistic updates feel instant",
        "âœ“ Sign-out clears cards from state"
      ]
    }
  ],
  "rollback_plan": {
    "description": "Auth-only mode - no localStorage fallback",
    "approach": "Show error state with retry option",
    "steps": [
      "If fetchCustomCards fails: Display error message",
      "Provide 'Retry' button to re-fetch",
      "If auth fails: Redirect to /login",
      "No offline mode (auth required)"
    ]
  },
  "security_considerations": [
    "RLS policies enforce user data isolation",
    "JSONB validation prevents malicious data",
    "Rate limiting on Supabase prevents abuse",
    "Auth tokens stored securely via Supabase SDK"
  ],
  "performance_considerations": [
    "Index on user_id for fast queries",
    "JSONB for flexible link storage without joins",
    "Optimistic updates reduce perceived latency",
    "Realtime subscriptions use WebSockets (efficient)"
  ],
  "edge_cases": [
    {
      "case": "User signs out",
      "handling": "Clear Supabase cards from state, don't save to localStorage"
    },
    {
      "case": "User deletes account",
      "handling": "ON DELETE CASCADE removes all cards automatically"
    },
    {
      "case": "Network offline",
      "handling": "Show error, allow retry, or fall back to localStorage"
    },
    {
      "case": "Conflicting updates",
      "handling": "Last write wins (or implement CRDT for conflict-free sync)"
    }
  ],
  "next_steps_after_implementation": [
    "Add card sharing (share custom cards with other users)",
    "Add card templates (pre-built cards users can clone)",
    "Add card categories/tags for organization",
    "Add card search/filter functionality",
    "Add card export/import (JSON)",
    "Add card analytics (most used actions)"
  ]
}
