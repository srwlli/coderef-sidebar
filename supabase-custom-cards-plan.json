{
  "title": "Supabase Per-User Custom Cards Implementation Plan",
  "version": "2.0.0",
  "status": "pending",
  "architecture_decision": {
    "auth_required": true,
    "guest_mode": false,
    "rationale": "Dashboard is auth-protected route. No localStorage, no migration, simpler implementation.",
    "see": "docs/ARCHITECTURE-DECISION.md"
  },
  "documentation": {
    "start_here": "docs/IMPLEMENTATION-READINESS.md",
    "architecture": "docs/ARCHITECTURE-DECISION.md",
    "security": "docs/api-security-patterns.md",
    "zustand_store": "docs/zustand-supabase-store-implementation.md",
    "auth_integration": "docs/auth-integration.md",
    "auth_and_offline": "docs/auth-and-offline-strategy.md",
    "field_mapping": "docs/field-name-mapping.md",
    "migration_flow": "docs/custom-cards-migration-flow.md",
    "type_generation": "docs/supabase-type-generation.md",
    "retry_patterns": "docs/retry-logic-patterns.md",
    "conflict_resolution": "docs/conflict-resolution.md"
  },
  "auth_token_handling": {
    "token_management": "Supabase SDK automatically manages access tokens and refresh tokens",
    "token_refresh": {
      "mechanism": "SDK auto-refreshes access token before expiration using refresh token",
      "frequency": "Access tokens expire after 1 hour (default), SDK refreshes ~5 minutes before expiry",
      "storage": "Tokens stored in localStorage by Supabase SDK (encrypted in memory during use)"
    },
    "auth_state_monitoring": {
      "implementation": "supabase.auth.onAuthStateChange((event, session) => { ... })",
      "events": {
        "SIGNED_IN": "User authenticated successfully",
        "SIGNED_OUT": "User signed out or session invalidated",
        "TOKEN_REFRESHED": "Access token refreshed successfully (automatic)",
        "USER_UPDATED": "User metadata updated",
        "PASSWORD_RECOVERY": "Password reset flow initiated"
      }
    },
    "expired_session_handling": {
      "scenario": "Refresh token expired or invalid",
      "detection": "onAuthStateChange fires SIGNED_OUT event when refresh fails",
      "action": "AuthProvider sets user to null, useEffect in dashboard redirects to /login",
      "user_message": "Your session has expired. Please sign in again."
    },
    "api_calls_with_auth": {
      "how_it_works": "Supabase client automatically attaches access token to all API calls",
      "user_context": "supabase.auth.getUser() retrieves current user from session (cached, no API call)",
      "rls_enforcement": "Database RLS policies use auth.uid() from JWT token to filter data",
      "no_token_scenario": "If no valid token, supabase.auth.getUser() returns { user: null }, API throws 'Not authenticated' error"
    },
    "store_integration": {
      "on_auth_required": "All Zustand store actions call supabase.auth.getUser() before API operations",
      "error_handling": "If getUser() returns null, throw 'Not authenticated' error, caught by UI for redirect",
      "no_manual_token_management": "Store does NOT manually handle tokens - SDK does this automatically"
    }
  },
  "tasks": [
    {
      "id": 1,
      "name": "Create Supabase Database Schema",
      "description": "Create custom_cards table with user_id foreign key",
      "files": ["supabase/migrations/create_custom_cards_table.sql"],
      "implementation": {
        "sql": "create table if not exists public.custom_cards (\n  id uuid primary key default gen_random_uuid(),\n  user_id uuid references auth.users(id) on delete cascade not null,\n  title text not null check (char_length(title) <= 50),\n  icon_name text not null,\n  links jsonb not null,\n  created_at timestamp with time zone default now() not null,\n  updated_at timestamp with time zone default now() not null,\n  \n  -- JSONB validation for links array structure\n  constraint valid_links_structure check (\n    jsonb_typeof(links) = 'array' and\n    jsonb_array_length(links) >= 1 and\n    jsonb_array_length(links) <= 16\n  )\n);\n\n-- Create index for faster user queries\ncreate index custom_cards_user_id_idx on public.custom_cards(user_id);\n\n-- Create index for ordering by created_at\ncreate index custom_cards_created_at_idx on public.custom_cards(created_at);\n\n-- Create function to validate each link object\ncreate or replace function validate_link_object(link jsonb)\nreturns boolean as $$\nbegin\n  return (\n    link ? 'id' and\n    link ? 'label' and\n    link ? 'href' and\n    jsonb_typeof(link->'id') = 'string' and\n    jsonb_typeof(link->'label') = 'string' and\n    jsonb_typeof(link->'href') = 'string' and\n    char_length(link->>'label') > 0 and\n    char_length(link->>'label') <= 30 and\n    char_length(link->>'href') > 0\n  );\nend;\n$$ language plpgsql immutable;\n\n-- Add constraint to validate all links in array\nalter table public.custom_cards add constraint valid_links_content check (\n  (select bool_and(validate_link_object(link))\n   from jsonb_array_elements(links) as link)\n);"
      },
      "notes": [
        "Use gen_random_uuid() instead of uuid_generate_v4() (Postgres 13+)",
        "Add check constraint for title length (max 50 chars)",
        "JSONB validation ensures 1-16 links with proper structure",
        "Each link validated: must have id, label (max 30 chars), href",
        "Prevents malicious/malformed data at database level",
        "Indexes for performance on user_id and created_at"
      ]
    },
    {
      "id": 2,
      "name": "Add Row Level Security Policies",
      "description": "Enable RLS so users can only access their own cards",
      "files": ["supabase/migrations/create_custom_cards_table.sql"],
      "implementation": {
        "sql": "-- Enable RLS\nalter table public.custom_cards enable row level security;\n\n-- Policy: Users can view their own cards\ncreate policy \"Users can view own custom cards\"\n  on public.custom_cards\n  for select\n  using (auth.uid() = user_id);\n\n-- Policy: Users can insert their own cards\ncreate policy \"Users can insert own custom cards\"\n  on public.custom_cards\n  for insert\n  with check (auth.uid() = user_id);\n\n-- Policy: Users can update their own cards\ncreate policy \"Users can update own custom cards\"\n  on public.custom_cards\n  for update\n  using (auth.uid() = user_id)\n  with check (auth.uid() = user_id);\n\n-- Policy: Users can delete their own cards\ncreate policy \"Users can delete own custom cards\"\n  on public.custom_cards\n  for delete\n  using (auth.uid() = user_id);"
      },
      "notes": [
        "RLS ensures data isolation per user",
        "auth.uid() returns current authenticated user's ID",
        "All CRUD operations protected by RLS"
      ]
    },
    {
      "id": 3,
      "name": "Add Updated Timestamp Trigger",
      "description": "Auto-update updated_at timestamp on row changes",
      "files": ["supabase/migrations/create_custom_cards_table.sql"],
      "implementation": {
        "sql": "-- Function to update updated_at timestamp\ncreate or replace function public.update_updated_at_column()\nreturns trigger as $$\nbegin\n  new.updated_at = now();\n  return new;\nend;\n$$ language plpgsql;\n\n-- Trigger to auto-update updated_at\ncreate trigger update_custom_cards_updated_at\n  before update on public.custom_cards\n  for each row\n  execute function public.update_updated_at_column();"
      },
      "notes": [
        "Automatically tracks when cards are modified",
        "Useful for sync and conflict resolution"
      ]
    },
    {
      "id": 4,
      "name": "Create Field Mapping Layer (snake_case â†” camelCase)",
      "description": "Conversion layer between Database (snake_case) and App (camelCase)",
      "files": ["src/lib/api/field-mapping.ts"],
      "field_mappings": {
        "database_to_app": {
          "id": "id (no change)",
          "user_id": "NOT in CustomCard (DB only)",
          "title": "title (no change)",
          "icon_name": "iconName",
          "links": "links (no change)",
          "created_at": "createdAt",
          "updated_at": "NOT in CustomCard (DB only)"
        },
        "app_to_database": {
          "title": "title (no change)",
          "iconName": "icon_name",
          "links": "links (no change)"
        }
      },
      "implementation": {
        "types": {
          "CustomCardRow": "Database row (snake_case) - id, user_id, title, icon_name, links, created_at, updated_at",
          "CustomCardInsert": "Insert payload (snake_case) - user_id, title, icon_name, links",
          "CustomCardUpdate": "Update payload (snake_case) - title?, icon_name?, links?"
        },
        "functions": {
          "dbToApp": "function dbToApp(row: CustomCardRow): CustomCard - Converts DB row to app model",
          "appToInsert": "function appToInsert(card, userId): CustomCardInsert - Converts app model to insert payload",
          "appToUpdate": "function appToUpdate(updates): CustomCardUpdate - Converts app updates to DB payload",
          "isCustomCardRow": "function isCustomCardRow(obj): boolean - Type guard for runtime validation"
        }
      },
      "usage_in_api": {
        "fetch": "const rows = await supabase.from('custom_cards').select('*');\nreturn rows.map(dbToApp);",
        "create": "const payload = appToInsert(card, user.id);\nconst row = await supabase.from('custom_cards').insert(payload).single();\nreturn dbToApp(row);",
        "update": "const payload = appToUpdate(updates);\nconst row = await supabase.from('custom_cards').update(payload).eq('id', id).single();\nreturn dbToApp(row);"
      },
      "benefits": [
        "Type safety: Compile-time checks for correct field names",
        "Single source of truth: Conversion logic centralized",
        "Testable: Pure functions easy to unit test",
        "Maintainable: Add new fields in one place",
        "Clear boundaries: DB layer vs App layer separation"
      ],
      "notes": [
        "Complete implementation in docs/field-name-mapping.md",
        "Database uses snake_case (PostgreSQL convention)",
        "App uses camelCase (TypeScript convention)",
        "Conversion happens at API boundary only",
        "user_id injected from auth.getUser(), not from app",
        "updated_at auto-updated by DB trigger, not exposed to app"
      ],
      "documentation": "docs/field-name-mapping.md"
    },
    {
      "id": 5,
      "name": "Create Custom Cards API Service",
      "description": "CRUD functions for custom cards in Supabase with field mapping",
      "files": ["src/lib/api/custom-cards.ts"],
      "dependencies": ["Task 4 - Field mapping layer required"],
      "implementation": {
        "functions": {
          "fetchCustomCardsFromSupabase": {
            "signature": "(): Promise<CustomCard[]>",
            "description": "Fetch all cards for authenticated user",
            "steps": [
              "1. Get user from supabase.auth.getUser()",
              "2. SELECT * FROM custom_cards WHERE user_id = user.id",
              "3. Map rows using dbToApp() from Task 4",
              "4. Return CustomCard[] (camelCase)"
            ]
          },
          "createCustomCardInSupabase": {
            "signature": "(card: Omit<CustomCard, 'id' | 'createdAt'>): Promise<CustomCard>",
            "description": "Create new card",
            "steps": [
              "1. Get user from supabase.auth.getUser()",
              "2. Convert using appToInsert(card, user.id) from Task 4",
              "3. INSERT into custom_cards",
              "4. Convert returned row using dbToApp()",
              "5. Return CustomCard (camelCase)"
            ]
          },
          "updateCustomCardInSupabase": {
            "signature": "(id: string, updates: Partial<Omit<CustomCard, 'id' | 'createdAt'>>): Promise<CustomCard>",
            "description": "Update existing card",
            "steps": [
              "1. Get user from supabase.auth.getUser()",
              "2. Convert using appToUpdate(updates) from Task 4",
              "3. UPDATE custom_cards WHERE id = id AND user_id = user.id",
              "4. Convert returned row using dbToApp()",
              "5. Return CustomCard (camelCase)"
            ]
          },
          "deleteCustomCardFromSupabase": {
            "signature": "(id: string): Promise<void>",
            "description": "Delete card",
            "steps": [
              "1. Get user from supabase.auth.getUser()",
              "2. DELETE FROM custom_cards WHERE id = id AND user_id = user.id",
              "3. Throw error if failed"
            ]
          }
        }
      },
      "error_handling": [
        "Throw 'Supabase not configured' if supabase is null",
        "Throw 'Not authenticated' if no user",
        "Throw Supabase error on query failure",
        "All errors propagate to caller (store) for handling"
      ],
      "security": [
        "CRITICAL: user_id MUST be retrieved from supabase.auth.getUser() inside each API function",
        "NEVER accept user_id as a parameter from caller - prevents data forgery",
        "Each function signature does NOT include userId parameter - it's internally retrieved",
        "RLS policies enforce user isolation at database level (defense in depth)",
        "UPDATE/DELETE include explicit user_id check for extra safety",
        "If auth.getUser() returns null, throw 'Not authenticated' immediately"
      ],
      "user_id_injection_pattern": {
        "correct": "const { data: { user } } = await supabase.auth.getUser();\nif (!user) throw new Error('Not authenticated');\nconst { data } = await supabase.from('custom_cards').insert({ user_id: user.id, ...payload });",
        "incorrect_never_do_this": "export async function createCard(card, userId) { // WRONG - userId from caller can be forged\n  await supabase.from('custom_cards').insert({ user_id: userId, ...payload });\n}"
      },
      "notes": [
        "Uses field mapping from Task 4",
        "All functions async (return Promises)",
        "Error handling delegates to caller",
        "RLS automatically filters by user_id",
        "Complete implementation in docs/field-name-mapping.md",
        "CRITICAL: Read docs/api-security-patterns.md before implementing"
      ],
      "documentation": "docs/api-security-patterns.md"
    },
    {
      "id": 6,
      "name": "Update Zustand Store with Supabase Integration",
      "description": "Auth-only store with Supabase integration and optimistic updates",
      "files": ["src/stores/use-app-store.ts"],
      "implementation": {
        "interface": {
          "new_state": [
            "isLoadingCards: boolean - Loading state for async operations",
            "cardsError: string | null - Error message from failed operations"
          ],
          "actions": [
            "fetchCustomCards: () => Promise<void> - Fetch from Supabase",
            "addCustomCard: (card) => Promise<void> - Add with optimistic update",
            "updateCustomCard: (id, updates) => Promise<void> - Update with optimistic update",
            "deleteCustomCard: (id) => Promise<void> - Delete with optimistic update",
            "clearCardsError: () => void - Clear error state"
          ]
        },
        "optimistic_update_pattern": {
          "add": "1. Generate temp ID\n2. Add temp card to state\n3. Insert to Supabase\n4. On success: replace temp with server card\n5. On failure: remove temp card + set error",
          "update": "1. Store original card\n2. Apply update to state\n3. Update in Supabase\n4. On failure: rollback to original + set error",
          "delete": "1. Store original card\n2. Remove from state\n3. Delete from Supabase\n4. On failure: re-add original + set error"
        },
        "persistence_strategy": "partialize: (state) => ({\n  view: state.view,\n  sidebarOpen: state.sidebarOpen,\n  // Don't persist customCards (fetched from Supabase on auth)\n})"
      },
      "key_features": [
        "Supabase-only (no guest mode)",
        "Optimistic updates with automatic rollback on error",
        "Loading and error states for UI feedback",
        "Temp ID pattern (temp-${uuid}) for optimistic creates",
        "Original card backup for update/delete rollback",
        "Cards fetched from Supabase on sign-in, cleared on sign-out"
      ],
      "usage": "const { fetchCustomCards, addCustomCard, isLoadingCards, cardsError } = useAppStore();\nuseEffect(() => { if (user) fetchCustomCards(); }, [user?.id]);\nawait addCustomCard(data);",
      "error_handling": [
        "Network errors: Rollback optimistic update, set cardsError",
        "Validation errors: Thrown to caller for UI handling",
        "All errors re-thrown after rollback for toast notifications"
      ],
      "notes": [
        "ARCHITECTURE: Auth-only, no guest mode (see docs/ARCHITECTURE-DECISION.md)",
        "Complete implementation in docs/zustand-supabase-store-implementation.md",
        "Optimistic updates provide instant UI feedback",
        "Rollback mechanism ensures data consistency"
      ]
    },
    {
      "id": 7,
      "name": "Create useCustomCards Hook",
      "description": "React hook to manage custom cards with auth integration",
      "files": ["src/hooks/use-custom-cards.ts"],
      "implementation": {
        "hook": "export function useCustomCards() {\n  const { user } = useAuth();\n  const { customCards, fetchCustomCards, addCustomCard, updateCustomCard, deleteCustomCard, isLoading, error } = useAppStore();\n\n  // Fetch cards on mount if authenticated\n  useEffect(() => {\n    if (user) {\n      fetchCustomCards();\n    }\n  }, [user?.id]);\n\n  return {\n    cards: customCards,\n    isLoading,\n    error,\n    addCard: addCustomCard,\n    updateCard: updateCustomCard,\n    deleteCard: deleteCustomCard,\n  };\n}"
      },
      "notes": [
        "Abstracts store complexity",
        "Auto-fetches on auth state change",
        "Provides clean API for components"
      ]
    },
    {
      "id": 8,
      "name": "Update Dashboard to Use New Hook",
      "description": "Replace direct store usage with useCustomCards hook",
      "files": ["src/app/(app)/dashboard/page.tsx"],
      "changes": [
        "Replace useAppStore with useCustomCards",
        "Add loading spinner while fetching",
        "Add error toast on failures",
        "Handle auth vs non-auth states"
      ],
      "notes": [
        "Show skeleton loaders while isLoading",
        "Display error messages with retry button",
        "Graceful fallback for non-auth users"
      ]
    },
    {
      "id": 9,
      "name": "Update Auth Provider for Card Lifecycle",
      "description": "Clear cards on sign-out (auth-only, no migration needed)",
      "files": ["src/lib/auth-context.tsx"],
      "existing_implementation": {
        "status": "Already exists - needs minor enhancement",
        "current_features": [
          "AuthProvider component wraps app",
          "useAuth hook provides user, loading, signIn, signUp, signOut, resetPassword",
          "onAuthStateChange listener updates user state",
          "Session persistence via Supabase SDK",
          "Automatic token refresh"
        ],
        "user_object": {
          "id": "string - Supabase user UUID (use for DB queries)",
          "email": "string - User email",
          "full_name": "string | undefined - Display name from user_metadata",
          "avatar_url": "string | undefined - Avatar URL from user_metadata"
        }
      },
      "required_changes": [
        "Import useAppStore to clear cards on sign-out",
        "Add card clearing in onAuthStateChange SIGNED_OUT event"
      ],
      "implementation": {
        "code": "import { useAppStore } from '@/stores/use-app-store';\n\n// In onAuthStateChange listener:\nsupabase.auth.onAuthStateChange((event, session) => {\n  setUser(session?.user ?? null);\n  setLoading(false);\n\n  // Clear Supabase cards on sign-out\n  if (event === 'SIGNED_OUT') {\n    useAppStore.setState({ customCards: [] });\n  }\n});"
      },
      "auth_events": {
        "SIGNED_IN": "No action needed (fetchCustomCards called by useEffect in dashboard)",
        "SIGNED_OUT": "Clear customCards from Zustand state",
        "TOKEN_REFRESHED": "No action needed (automatic)",
        "USER_UPDATED": "No action needed (user state updates automatically)",
        "PASSWORD_RECOVERY": "No action needed for custom cards"
      },
      "notes": [
        "ARCHITECTURE: Auth-only, no migration needed (see docs/ARCHITECTURE-DECISION.md)",
        "useAuth hook already exists - see docs/auth-integration.md",
        "Cards cleared on sign-out to prevent stale data",
        "fetchCustomCards triggered by useCustomCards hook in dashboard"
      ],
      "documentation": "docs/auth-integration.md"
    },
    {
      "id": 10,
      "name": "Add Route Protection to Dashboard",
      "description": "Protect dashboard route - require authentication",
      "files": ["src/app/(app)/dashboard/page.tsx"],
      "implementation": {
        "code": "import { useAuth } from '@/lib/auth-context';\nimport { useRouter } from 'next/navigation';\nimport { useEffect } from 'react';\n\nexport default function Dashboard() {\n  const { user, loading } = useAuth();\n  const router = useRouter();\n\n  useEffect(() => {\n    if (!loading && !user) {\n      router.push('/login');\n    }\n  }, [user, loading, router]);\n\n  if (loading) return <Spinner />;\n  if (!user) return null; // Redirecting\n\n  return <DashboardContent />;\n}"
      },
      "required_changes": [
        "Import useAuth hook",
        "Import useRouter for navigation",
        "Add auth check in useEffect",
        "Show loading spinner during auth check",
        "Redirect to /login if not authenticated",
        "Render dashboard only when authenticated"
      ],
      "notes": [
        "ARCHITECTURE: Auth-only dashboard (see docs/ARCHITECTURE-DECISION.md)",
        "Default cards (Prompts, Git Commands, etc.) can be on different public route",
        "Custom cards only accessible when authenticated",
        "useCustomCards hook will auto-fetch on mount"
      ]
    },
    {
      "id": 11,
      "name": "Add Optimistic Updates",
      "description": "Update UI immediately, rollback on server error",
      "files": ["src/stores/use-app-store.ts"],
      "implementation": {
        "pattern": "1. Add card to state immediately\n2. Call Supabase API\n3. On success: update with server ID\n4. On failure: remove from state + show error"
      },
      "notes": [
        "Better UX with instant feedback",
        "Graceful error handling",
        "State consistency with server"
      ]
    },
    {
      "id": 12,
      "name": "Add Realtime Sync (Optional)",
      "description": "Sync cards across devices in realtime with proper cleanup",
      "files": ["src/hooks/use-custom-cards.ts"],
      "implementation": {
        "code": "// src/hooks/use-custom-cards.ts\nimport { useEffect } from 'react';\nimport { supabase } from '@/lib/supabase';\nimport { useAuth } from '@/lib/auth-context';\nimport { useAppStore } from '@/stores/use-app-store';\n\nexport function useCustomCards() {\n  const { user } = useAuth();\n  const { customCards, fetchCustomCards, addCustomCard, updateCustomCard, deleteCustomCard } = useAppStore();\n\n  // Subscribe to realtime changes\n  useEffect(() => {\n    if (!user || !supabase) return;\n\n    // Create channel\n    const channel = supabase\n      .channel(`custom_cards:${user.id}`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*', // INSERT, UPDATE, DELETE\n          schema: 'public',\n          table: 'custom_cards',\n          filter: `user_id=eq.${user.id}`,\n        },\n        (payload) => {\n          console.log('Realtime change:', payload);\n\n          // Handle different events\n          if (payload.eventType === 'INSERT') {\n            // Another device created a card\n            const newCard = dbToApp(payload.new);\n            useAppStore.setState({\n              customCards: [...useAppStore.getState().customCards, newCard],\n            });\n          } else if (payload.eventType === 'UPDATE') {\n            // Another device updated a card\n            const updatedCard = dbToApp(payload.new);\n            useAppStore.setState({\n              customCards: useAppStore.getState().customCards.map((c) =>\n                c.id === updatedCard.id ? updatedCard : c\n              ),\n            });\n          } else if (payload.eventType === 'DELETE') {\n            // Another device deleted a card\n            useAppStore.setState({\n              customCards: useAppStore.getState().customCards.filter(\n                (c) => c.id !== payload.old.id\n              ),\n            });\n          }\n        }\n      )\n      .subscribe();\n\n    // Cleanup function: unsubscribe when component unmounts or user changes\n    return () => {\n      console.log('Unsubscribing from realtime channel');\n      supabase.removeChannel(channel);\n    };\n  }, [user?.id]); // Re-subscribe if user changes\n\n  return {\n    cards: customCards,\n    addCard: addCustomCard,\n    updateCard: updateCustomCard,\n    deleteCard: deleteCustomCard,\n  };\n}",
        "cleanup_pattern": "useEffect cleanup function calls supabase.removeChannel(channel) to prevent memory leaks"
      },
      "important_notes": [
        "MUST call removeChannel() in cleanup to prevent memory leaks",
        "Re-subscribe when user.id changes",
        "Handle INSERT, UPDATE, DELETE events separately",
        "Use dbToApp() to convert realtime payloads to app format",
        "Cleanup runs on component unmount and user change"
      ],
      "edge_cases": [
        "User signs out: useEffect cleanup unsubscribes automatically",
        "Component unmounts: cleanup prevents orphaned subscriptions",
        "User switches accounts: Old channel cleaned up, new one created",
        "Multiple browser tabs: Each tab has own subscription (Supabase handles)"
      ],
      "notes": [
        "Optional enhancement - app works without this",
        "Useful for multi-device users",
        "Requires Realtime enabled in Supabase dashboard",
        "Cleanup pattern prevents memory leaks",
        "See Supabase Realtime docs for configuration"
      ]
    },
    {
      "id": 13,
      "name": "Configure Rate Limiting in Supabase Dashboard",
      "description": "Set up rate limiting to prevent API abuse",
      "category": "Configuration (Supabase Dashboard)",
      "implementation": {
        "location": "Supabase Dashboard > Settings > API",
        "settings": {
          "auth_rate_limits": {
            "sign_in": "10 requests per hour per IP (default: 30)",
            "sign_up": "5 requests per hour per IP (default: 30)",
            "password_reset": "5 requests per hour per email (default: 30)"
          },
          "database_rate_limits": {
            "read_operations": "1000 requests per minute per user (default: unlimited)",
            "write_operations": "100 requests per minute per user (default: unlimited)",
            "realtime_connections": "100 concurrent connections per user (default: 500)"
          },
          "custom_rate_limits_via_edge_functions": {
            "description": "Use Supabase Edge Functions for custom rate limiting",
            "example": "Limit custom_cards operations to 50 creates/updates/deletes per hour per user"
          }
        }
      },
      "recommended_limits": [
        "custom_cards INSERT: 20 per hour per user (prevent spam)",
        "custom_cards UPDATE: 50 per hour per user (allow editing)",
        "custom_cards DELETE: 20 per hour per user (prevent accidents)",
        "custom_cards SELECT: 1000 per hour per user (allow browsing)"
      ],
      "implementation_methods": {
        "method_1_rls_with_counter": {
          "description": "Use PostgreSQL table to track request counts",
          "steps": [
            "1. Create rate_limit_tracker table (user_id, action, count, window_start)",
            "2. Add trigger on custom_cards INSERT/UPDATE/DELETE",
            "3. Check count in trigger, reject if over limit",
            "4. Reset count every hour via cron job"
          ],
          "pros": ["Database-enforced", "Works with any client"],
          "cons": ["Complex to implement", "Adds DB overhead"]
        },
        "method_2_edge_functions": {
          "description": "Use Supabase Edge Functions as middleware",
          "steps": [
            "1. Create Edge Function to intercept requests",
            "2. Track requests in Redis or Upstash",
            "3. Return 429 Too Many Requests if over limit",
            "4. Call actual Supabase function if under limit"
          ],
          "pros": ["Flexible", "Low DB overhead"],
          "cons": ["Requires Edge Functions (Pro plan)"]
        },
        "method_3_client_side": {
          "description": "Implement rate limiting in app code",
          "steps": [
            "1. Track operations in zustand store",
            "2. Show warning if user exceeds soft limit",
            "3. Disable buttons temporarily if over limit"
          ],
          "pros": ["Easy to implement", "Good UX"],
          "cons": ["Not enforceable (user can bypass)"]
        }
      },
      "recommended_approach": "Method 3 (Client-side) for MVP, upgrade to Method 2 (Edge Functions) if abuse detected",
      "client_side_implementation": {
        "zustand_store_addition": "rateLimitTracker: { creates: [], updates: [], deletes: [] } - Track timestamps",
        "before_operation_check": "const recentCreates = rateLimitTracker.creates.filter(t => t > Date.now() - 3600000);\nif (recentCreates.length >= 20) {\n  throw new Error('Rate limit exceeded. Please wait before creating more cards.');\n}",
        "after_operation": "rateLimitTracker.creates.push(Date.now());"
      },
      "dashboard_configuration_steps": [
        "1. Go to Supabase Dashboard > Project Settings > API",
        "2. Enable 'Rate Limiting' toggle",
        "3. Set custom limits for Auth endpoints",
        "4. Monitor usage in Dashboard > Database > Logs",
        "5. Adjust limits based on actual usage patterns"
      ],
      "notes": [
        "Built-in Supabase rate limiting is IP-based (not user-based)",
        "For user-based limits, implement custom solution",
        "Start with client-side limits (easy), add server-side if needed",
        "Monitor Supabase logs for abuse patterns",
        "Consider implementing per-user quotas in future"
      ],
      "monitoring": {
        "supabase_dashboard": "Dashboard > Database > Logs - Filter by table custom_cards",
        "client_side_tracking": "Log rate limit violations to analytics (e.g., Posthog, Mixpanel)",
        "alerts": "Set up email alerts if >100 failed operations per hour"
      }
    }
  ],
  "implementation_order": [
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13
  ],
  "removed_tasks": [
    {
      "original_id": 9,
      "name": "localStorage Migration",
      "reason": "Auth-only architecture - no guest mode, no migration needed"
    }
  ],
  "testing_checklist": [
    {
      "category": "Database",
      "tests": [
        "Table created with correct schema",
        "RLS policies prevent cross-user access",
        "Indexes improve query performance",
        "Triggers update timestamps correctly"
      ]
    },
    {
      "category": "API",
      "tests": [
        "fetchCustomCards returns only user's cards",
        "createCustomCard adds card to database",
        "updateCustomCard modifies existing card",
        "deleteCustomCard removes card",
        "Error handling for network failures",
        "RLS blocks unauthorized access attempts"
      ]
    },
    {
      "category": "Store",
      "tests": [
        "fetchCustomCards loads from Supabase",
        "Loading states update correctly",
        "Error states clear on success",
        "Optimistic updates rollback on error",
        "Cards cleared on sign-out"
      ]
    },
    {
      "category": "Route Protection",
      "tests": [
        "Dashboard redirects to /login when not authenticated",
        "Dashboard shows loading spinner during auth check",
        "Dashboard renders only when authenticated",
        "Custom cards fetch on mount (authenticated users)"
      ]
    },
    {
      "category": "UI/UX",
      "tests": [
        "Loading spinner shows while fetching",
        "Error messages display with retry option",
        "Cards update across devices (if realtime enabled)",
        "Optimistic updates feel instant",
        "Sign-out clears cards from state"
      ]
    }
  ],
  "rollback_plan": {
    "description": "Auth-only mode - no localStorage fallback",
    "approach": "Show error state with retry option",
    "steps": [
      "If fetchCustomCards fails: Display error message",
      "Provide 'Retry' button to re-fetch",
      "If auth fails: Redirect to /login",
      "No offline mode (auth required)"
    ]
  },
  "security_considerations": [
    "RLS policies enforce user data isolation",
    "JSONB validation prevents malicious data",
    "Rate limiting on Supabase prevents abuse",
    "Auth tokens stored securely via Supabase SDK"
  ],
  "performance_considerations": [
    "Index on user_id for fast queries",
    "JSONB for flexible link storage without joins",
    "Optimistic updates reduce perceived latency",
    "Realtime subscriptions use WebSockets (efficient)"
  ],
  "edge_cases": [
    {
      "case": "User signs out",
      "handling": "Clear Supabase cards from state, don't save to localStorage"
    },
    {
      "case": "User deletes account",
      "handling": "ON DELETE CASCADE removes all cards automatically"
    },
    {
      "case": "Network offline",
      "handling": "Auth-only mode - show error message with retry button. Block CRUD actions until connection restored. No localStorage fallback.",
      "offline_strategy": "Display: 'You are offline. Custom cards require an internet connection.' with retry option",
      "future_enhancement": "Optional: Implement offline queue with retry on reconnect (see docs/retry-logic-patterns.md)"
    },
    {
      "case": "Session expired / Auth token invalid",
      "handling": "Supabase SDK auto-refreshes tokens. If refresh fails, redirect to /login with session expired message",
      "implementation": "supabase.auth.onAuthStateChange listens for TOKEN_REFRESHED and SIGNED_OUT events",
      "user_experience": "Seamless for valid sessions, explicit re-login prompt if session cannot be refreshed"
    },
    {
      "case": "Conflicting updates",
      "handling": "Last write wins (or implement CRDT for conflict-free sync)",
      "documentation": "docs/conflict-resolution.md",
      "recommended_strategy": "Last-Write-Wins for MVP (Strategy 1)",
      "future_options": ["Optimistic Locking (Strategy 2)", "Field-Level Merging (Strategy 3)", "CRDTs (Strategy 4)"]
    }
  ],
  "next_steps_after_implementation": [
    "Add card sharing (share custom cards with other users)",
    "Add card templates (pre-built cards users can clone)",
    "Add card categories/tags for organization",
    "Add card search/filter functionality",
    "Add card export/import (JSON)",
    "Add card analytics (most used actions)"
  ]
}
